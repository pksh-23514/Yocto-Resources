Dynamic Libraries:
==================
1. A dynamic library (also called as Shared library) is a collection of functions and procedures that are loaded into the program at the Run-time.
2. This type of linking is called dynamic linking.
3. The code is not included as a part of the binary. Instead, it is linked dynamically whenever the binary is executed.
4. The utility used to create the dynamic libraries is GCC (gcc).
5. The dynamic libraries have an extension of '.so' in Linux.

Steps to Create a Dynamic Library:
==================================
1. The first step is to collect all the C files and the Header files that needs to be included in the dynamic library.
2. The C files must be partially Compiled by using the '-c' option along with the '-fPIC' option to generate their individual position independent code Object files.
	=> gcc -c -fPIC <file-1>.c <file-2>.c ...
	---> '-fPIC' is used to generate the Object files with Relative Addressing (instead of Absolute Addressing). These Addresses can be modified at the Run-time.
3. The Object files are created from the C files with an extension of '.o' in Linux.
4. After the Object files are generated, they can be used to create the dynamic library by using the GCC utility with the '-shared' option.
	=> gcc -shared -Wl,-soname,SONAME -o lib_dynamic-lib-name.so.major.minor.patch <file-1>.o <file-2>.o ...
	---> '-shared' is used to create a Shared library.
	---> '-Wl' is used to pass a comma-separated options to the Linker.
	---> 'SONAME' is the Shared Object name embedded inside the dynamic library ELF.
	---> 'lib_dynamic-lib-name.so.major.minor.patch' is a conventional way to name the versioned libraries.
5. The versioned dynamic library is created from the position independent Object files with an extension of '.so' in Linux.
6. The Symbolic links must be created for the versioned dynamic library to manage the inerface changes and compatibility to be used at the Run-time.
	=> ln -s lib_dynamic-lib-name.so.major.minor.patch lib_dynamic-lib-name.so.major
	=> ln -s lib_dynamic-lib-name.so.major lib_dynamic-lib-name.so
	---> The 'lib_dynamic-lib-name.so.major' is referred to as the SONAME of the dynamic library.
	---> The 'lib_dynamic-lib-name.so' is referred to as the Linker name of the dynamic library.
7. The additional step (which is not a part of the Recipes) to use this dynamic library while Compiling a C file.
	=> gcc <file.c> -o <file> -I<path-to-Header-file> -l_dynamic-lib-name.so -L<path-to-dynamic-library>
	---> '-I' is used to provide the path to the Header file especially when it is placed in a non-standard location.
	---> '-l' is used to provide the library name to be linked. Only the name of the library without the extension and along with '_' (if present) must be provided.
	---> '-L' is used to provide the path to the library especially when it is placed in a non-standard location.
8. There is one more additional step (which is not a part of the Recipes) necessary to run the binary generated using dynamic linking.
	=> export LD_LIBRARY_PATH=<path-to-dynamic-library>
	---> 'LD_LIBRARY_PATH' is an Environment variable used by the dynamic Linker at the Run-time. It is used to specify the path to the dynamic library.

Real Versioned Library Name:
****************************
1. This is the actual name of the dynamic library. All the other Symbolic links are made to point to this actual library name.
2. It is possible that the multiple versions of the same dynamic library can be co-existing in the same system.
3. Therefore, the dynamic libraries often follows a naming convention to include the various versions in their name.
	1) Major Release
	2) Minor Release
	3) Patch Release
4. The actual name of the dynamic library has the following format:
	=> lib_dynamic-lib-name.so.major.minor.patch
	---> 'lib' is the prefix for the dynamic library name.
	---> '_dynamic-lib-name' is the real dynamic library name.

SONAME (Shared Object Name):
****************************
1. The SONAME is a Symbolic link that points to the actual dynamic library name. It is also embedded into the dynamic library ELF (as DT_SONAME).
2. This name is used by the dynamic Linker to identify the file during the dynamic linking.
3. It includes the same Major Release version as the actual name of the dynamic library. It points to the most recent Minor Release version for each Major Release version.
4. The SONAME of the dynamic library has the following format:
	=> lib_dynamic-lib-name.so.major
	---> 'lib' is the prefix for the dynamic library name.
	---> '_dynamic-lib-name' is the real dynamic library name.
5. The 'readelf -d' command displays the contents of the dynamic section (.dynamic) of an ELF. It is used to read the SONAME of the dynamic library.

Linker Name:
************
1. The Linker name is a Symbolic link that points to the SONAME which then points to the actual dynamic library name. It is not embedded into the dynamic library ELF.
2. This is the plain name used with the '-l' option while Compiling a C file along with the dynamic library.
	=> gcc <file.c> -o <file> -I<path-to-Header-file> -l_dynamic-lib-name.so -L<path-to-dynamic-library>
3. It doesn't include any of the version related information for the dynamic library.
4. The Linker name of the dynamic library has the following format:
	=> lib_dynamic-lib-name.so
	---> 'lib' is the prefix for the dynamic library name.
	---> '_dynamic-lib-name' is the real dynamic library name.

Symbolic Links:
***************
1. The order of the Symbolic links are as follows:
	=> Linker Name ---> SONAME
	=> SONAME ---> Latest versioned dynamic library name
2. So, if there is any upgrade to the dynamic library version, updating the SONAME to point to the latest version of the dynamic library is sufficient.
3. There is no need to upgrade the Linker name as it depends on the SONAME directly.
4. Therefore, the Symbolic links are created for the versioned dynamic library to manage the inerface changes and compatibility.
5. It allows the multiple versions of the same dynamic library to co-exist smoothly.
6. It makes the process of upgrading the dynamic library version fairly simple.

Un-Versioned Dynamic Libraries:
*******************************
1. In context of the Shared libraries, the versioned libraries are far more common than the un-versioned libraries.
2. Whenever a Shared library is generated using the source code along with their Symbolic links, they are usually versioned.
3. However, sometimes the library developers do not provide the source code for the dynamic library but they do Release the pre-Built dynamic library for usage.
4. If such Shared libraries are included in the Yocto Build, the Build would fail as the default rules during the 'do_package_qa' Task assumes the libraries to be versioned.
	1) The '${PN}-dev' Package is by default assumed to have a Symbolic link to the dynamic library. The Symbolic link should be un-versioned.
	2) The '/lib/lib*.so' or the '/usr/lib/lib*.so' files are by default packaged into the '${PN}-dev' Package.
	3) The pre-Built dynamic library is un-versioned and by default, it will be placed under the '${PN}-dev' Package.
	4) Hence, the '${PN}-dev' Package is actually containing the real library instead of the Symbolic link to dynamic library which throws the error during the Build.
5. The Packaging of the un-versioned dynamic libraries requires certain modifications in the Recipes to resolve the QA error encountered during the Build.
	1) By default, the '.so' files are packaged into the '${PN}-dev' Package which then throws the error of the presence of non-Symbolic link in the Package.
	2) To resolve the error, the Recipe file should be updated for the BitBake to place the un-versioned dynamic library i.e. '.so' files into the '${PN}' Package.
	3) The 'SOLIBS' variable is used to define the suffix for the Shared libraries that are to be used on the Target.
		=> SOLIBS = ".so.*"
		---> This variable is referenced in the default values of the 'FILES:${PN}' variable.
		=> FILES:${PN} = "${bindir}/* ${sbindir}/* ${libexecdir}/* ${libdir}/lib*${SOLIBS} ... ${base_libdir}/*${SOLIBS} ..."
	4) The 'SOLIBSDEV' variable is used to define the suffix for the development Symbolic link for the Shared libraries that are to be used on the Target.
		=> SOLIBSDEV = ".so"
		---> This variable is referenced in the default values of the 'FILES:${PN}-dev' variable.
		=> FILES:${PN}-dev = "${includedir} ${FILES_SOLIBSDEV} ${libdir}/*.la ..."
		=> FILES_SOLIBSDEV ?= "${base_libdir}/lib*${SOLIBSDEV} ${libdir}/lib*${SOLIBSDEV}"
	5) The default value for both the 'SOLIBS' and the 'SOLIBSDEV' variables is specified in the 'meta/conf/bitbake.conf' file.
	6) The 'SOLIBS' variable is used to put the real versioned dynamic library or the versioned Symbolic link to the dynamic library into the '${PN}' Package.
	7) The 'SOLIBSDEV' variable is used to put the real un-versioned dynamic library or the un-versioned Symbolic link to the dynamic library into the '${PN}-dev' Package.
	8) The Recipe file should be updated with the below variables to resolve the error:
		=> SOLIBS = ".so"
		=> FILES_SOLIBSDEV = ""
	9) This overrides the default behavior of the BitBake to place the un-versioned dynamic library i.e. '.so' files into the '${PN}-dev' Package.
