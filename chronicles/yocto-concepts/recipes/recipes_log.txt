Logging the Build Tasks in Recipes:
===================================
1. The Build logs for each of the BitBake Tasks executed for the Recipes are stored in their respective 'WORKDIR' directory.
2. The individual Recipe stores all the logs under the 'temp' directory.
	1) The 'T' variable is used to point to the 'temp' directory for the particular Recipe.
		=> bitbake -e recipe-name | grep ^T=
	2) This 'temp' directory is used by the BitBake to store the temporary files while Building the particular Recipe.
	3) The default value of the variable is defined in the 'meta/conf/bitbake.conf' file.
		=> T = "${WORKDIR}/temp"
3. Each Task that is executed during the individual Recipe Build produces the following kind of files in the 'WORKDIR/temp' directory.
	1) The 'log' file which is the Output log from 'stdout' or 'stderr' for a specific Task executed by the BitBake. It is helpful to debug when a particular Task fails.
	2) The 'run' file which is the actual script containing the commands executed for a specific Task by the BitBake. It is generated based on the Recipe's Meta-data.
4. The naming convention for the 'log' and the 'run' files are as follows:
	1) log.do_<task>.pid
	2) run.<task>.pid
	---> The 'task' represents the name of the specific Task being executed by the BitBake during the Recipe Build.
	---> The 'pid' represents the Linux PID of the specific Task being executed by the BitBake during the Recipe Build.
5. If the particular Recipe's Tasks are executed repeatedly, for each time the Task is executed, the 'log' and the 'run' files are newly generated with the corresponding PID.
6. Therefore, there are Symbolic link provided for each Task's 'log' and 'run' file. They point to the latest generated Task's 'log' and 'run' file respectively.
	=> log.do_compile ---> Latest 'log' file for the 'do_compile' Task executed for the particular Recipe Build.
	=> run.do_compile ---> Latest 'run' file for the 'do_compile' Task executed for the particular Recipe Build.
7. There is another single file in the 'temp' directory named as 'log.task_order'.
	1) It is created by the BitBake to list down all the Tasks in the order they were executed for the particular Recipe.
	2) It is used for checking the order in which the Tasks were executed and to understand why a particular Task was skipped during the Recipe Build.

Logging Mechanisms in Recipes:
==============================
1. The Yocto Project provides several logging functions for producing debugging Output and reporting the errors or warnings.
2. The BitBake provides the logging functions to be used in both the Python and the Shell code.
3. The following Python logging functions are available:
	1) bb.plain(msg) => It writes 'msg' as it is to the log file as well as to the 'stdout' i.e. printed on the Console.
	2) bb.note(msg) => It writes 'NOTE: msg' to the log file. It can write to the 'stdout' if the BitBake is called with '-v' option.
	3) bb.debug(level, msg) => It writes 'DEBUG: msg' to the log file. It can write to the 'stdout' if 'level' is smaller than the Debug-level set during the BitBake call.
	4) bb.warn(msg) => It writes 'WARNING: msg' to the log file as well as to the 'stdout'.
	5) bb.error(msg) => It writes 'ERROR: msg' to the log file as well as to the 'stdout'. However, this function call doesn't cause the Task execution to fail.
	6) bb.fatal(msg) => It is similar to the 'bb.error(msg)' function. However, this function call causes the Task execution to fail. It raises an Exception to the caller.
4. These Python logging functions are implemented in the BitBake's 'bb' Python Module.
	1) The 'bb' Module is imported implicitly in the BitBake parser.
	2) The Python logging functions can be called directly from inside the Recipes in the Python Task functions or inline Python code.
	3) Therefore, there is no need to explicitly import this Module inside the Recipes.
5. All the above mentioned Python logging functions write to:
	1) The respective Task's '${T}/log.do_<task>.pid' log file.
	2) The 'stdout' i.e. prints on the Console with the right settings provided to the functions.
6. The following Shell logging functions are available:
	1) bbplain => bb.plain(msg)
	2) bbnote => bb.note(msg)
	3) bbdebug => bb.debug(level, msg)
	4) bbwarn => bb.warn(msg)
	5) bberror => bb.error(msg)
	6) bbfatal => bb.fatal(msg)
7. The Shell logging functions are implemented in the 'meta/classes/logging.bbclass' file.
	1) This Class file is inherited by default in the Recipes.
	2) These Shell logging functions can be called directly from inside the Recipes in the Shell Task functions.
	3) They are intended to map one to one in the intentions and the Output format with the Python logging functions of the similar naming convention.
8. All the above mentioned Shell functions write to:
	1) The respective Task's '${T}/log.do_<task>.pid' log file.
	2) The 'stdout' i.e. prints on the Console with the right settings provided to the functions.
9. If these Shell logging functions are being used in the Shell Task functions of the Recipes, they can be verified in:
	1) The respective Task's '${T}/run.<task>.pid' log file which defines the specific Shell logging function along with the other commands for the Task.
10. Among all the functions mentioned, the 'bb.fatal()' or the 'bbfatal' functions have the highest priority. They cause the Recipe Build to terminate with an error code.
11. The 'bb.debug(level. msg)' or the 'bbdebug' functions can only display the logs on the Console:
	1) If the parameter 'level' for the 'msg' is smaller than or equal to the Debug-level passed to the BitBake during the Recipes Build.
	2) To enable the Debug-level Output on Console, the '-D' option is used to increase the Debug-level in the range of 1 to 3.
		=> Level-0: bitbake recipe-name
		=> Level-1: bitbake -D recipe-name
		=> Level-2: bitbake -DD recipe-name
		=> Level-3: bitbake -DDD recipe-name
12. The color codes for the Output displayed on the Console by the functions are as follows:
	1) bb.fatal(msg) or bbfatal => Red
	2) bb.error(msg) or bberror => Red
	3) bb.warn(msg) or bbwarn => Yellow
	4) bb.plain(msg) or bbplain => White
	5) bb.debug(level, msg) or bbdebug => Cyan or Blue

Logging with Python Functions:
******************************
1. While creating the Recipes using Python and inserting code that handles Build logs, the goal should be:
	1) To have the most informative logs.
	2) The Console should be kept as 'silent' as possible.
2. If there is a requirement to display status messages in the log, the Debug-levels must be used.
3. The Python logging functions can be used in the Python Task function as follows:
	=> python do_listtasks() {
	=>     bb.debug(2, "Starting to figure out the Task list.")
	=>     if noteworthy_condition:
	=>         bb.note("There are 47 Tasks to run.")
	=>     bb.debug(2, "Got to point x.")
	=>     if warning_trigger:
	=>         bb.warn("Detected a warning trigger, this might be a problem later.")
	=>     if recoverable_error:
	=>         bb.error("Hit a recoverable error, need to fix this!")
	=>     if fatal_error:
	=>         bb.fatal("Fatal error detected, unable to print the Task list.")
	=>     bb.plain("The Tasks present are ...")
	=>     bb.debug(2, "Finished figuring out the Task list.")
	=> }

Logging with Shell Functions:
*****************************
1. While creating the Recipes using Shell and inserting code that handles Build logs, the goal should be:
	1) To have the most informative logs
	2) The Console should be kept as 'silent' as possible.
2. If there is a requirement to display status messages in the log, the Debug-levels must be used.
3. The Shell logging functions can be used in the Shell Task function as follows:
	=> do_my_function() {
	=>     bbdebug 2 "Running do_my_function."
	=>     if [ exceptional_condition ]; then
	=>         bbnote "Hit an exceptional condition."
	=>     fi
	=>     bbdebug 2  "Got to point x."
	=>     if [ warning_trigger ]; then
	=>         bbwarn "Detected a warning trigger, this might cause a problem later."
	=>     fi
	=>     if [ recoverable_error ]; then
	=>         bberror "Hit a recoverable error, correcting ..."
	=>     fi
	=>     if [ fatal_error ]; then
	=>         bbfatal "Fatal error detected!"
	=>     fi
	=>     bbdebug 2 "Completed do_my_function."
	=> }
