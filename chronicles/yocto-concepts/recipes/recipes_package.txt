Packaging using Recipes:
========================
1. Packaging is the process of taking the Built SW and organizing it into installable units called Packages.
2. The Built SW can include binaries, libraries, scripts, documentation etc.
3. The Packages are stored in the format of '.ipk', '.deb' or '.rpm'.
4. The Packages can be installed, updated or removed using the respective Package manager based on the Package format.
5. The successful Packaging is a combination of the automated processes performed by the OpenEmbedded Build system and some processes that need to be executed manually.

Packaging Process:
******************
1. Splitting the files:
	1) The 'do_package' Task splits the files generated by the Recipes into logical components.
	2) Even the Recipes that produce a single binary might stil have Debug-Symbols, documentation etc that should be split out logically.
	3) The 'do_package' Task ensures that the files are split up and organized correctly.
	4) This method improves flexibility of the Build system.
2. Running QA checks:
	1) The 'insane' Class is used to generate the QA checks performed om the Packages. It adds an additional step to the Package generation process.
	2) This step performs a range of checks to ensure that the Buildâ€™s Output is free of the common problems that show up during Run-time.
3. Manual checking the Packages:
	1) After the Packaging is successful, it must be inspected that the Packages are correct.
	2) The directory to be examined is:
		---> ${WORKDIR}/packages-split
	3) It must be ensured that the files are placed at their expected locations.
	4) If there are certain issues discovered, the 'PACKAGES', 'FILES', 'do_install:append' etc must be modified to resolve the issues with the Packages.
4. Installing the post-install scripts:
	1) The post-install scripts can be made to run immediately after installing a Package on the Target or during the Image creation when a Package is included in the Image.
5. Marking the Package Architecture:
	1) Depending on the Recipes Configuration and type of Build Output, it is important to mark the Package Architecture.
	2) The Packages can either be marked as specific to a particular Machine (like binaries) or can be marked as Machine or Architecture independent (like documentation).
	3) By default, the Packages are Architecture-specific i.e. they apply to any Machine with the same Architecture as that of the Target for which the Package is Built.
	4) If the Recipes produce Packages that are Machine-specific, then the default value should be modified in the Recipes as:
		=> PACKAGE_ARCH = "${MACHINE_ARCH}"
		---> It ensures that the Package generated is only used with the Machine it was Built for.
	5) If the Recipes produce Packages that do not contain anything specific to the Target Machine or Architecture (like scripts or documentation etc).
	6) These Packages are identical across all Target Architectures and they need not be Built separately for each Machine or Architecture.
	7) The 'allarch' Class must be inherited in the Recipes for the Packages that are Architecture independent:
		=> inherit allarch
