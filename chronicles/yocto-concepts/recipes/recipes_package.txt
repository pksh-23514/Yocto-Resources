Packaging using Recipes:
========================
1. Packaging is the process of taking the Built SW and organizing it into installable units called Packages.
2. The Built SW can include binaries, libraries, scripts, documentation etc.
3. The Packages are stored in the format of '.ipk', '.deb' or '.rpm'.
4. The Packages can be installed, updated or removed using the respective Package manager based on the Package format.
5. The successful Packaging is a combination of the automated processes performed by the OpenEmbedded Build system and some processes that need to be executed manually.

Packaging Process:
******************
1. Splitting the files:
	1) The 'do_package' Task splits the files generated by the Recipes into logical components.
	2) Even the Recipes that produce a single binary might stil have Debug-Symbols, documentation etc that should be split out logically.
	3) The 'do_package' Task ensures that the files are split up and organized correctly.
	4) This method improves flexibility of the Build system.
2. Running QA checks:
	1) The 'insane' Class is used to generate the QA checks performed om the Packages. It adds an additional step to the Package generation process.
	2) This step performs a range of checks to ensure that the Buildâ€™s Output is free of the common problems that show up during Run-time.
3. Manual checking the Packages:
	1) After the Packaging is successful, it must be inspected that the Packages are correct.
	2) The directory to be examined is:
		---> ${WORKDIR}/packages-split
	3) It must be ensured that the files are placed at their expected locations.
	4) If there are certain issues discovered, the 'PACKAGES', 'FILES', 'do_install:append' etc must be modified to resolve the issues with the Packages.
4. Installing the post-install scripts:
	1) The post-install scripts can be made to run immediately after installing a Package on the Target or during the Image creation when a Package is included in the Image.
5. Marking the Package Architecture:
	1) Depending on the Recipes Configuration and type of Build Output, it is important to mark the Package Architecture.
	2) The Packages can either be marked as specific to a particular Machine (like binaries) or can be marked as Machine or Architecture independent (like documentation).
	3) By default, the Packages are Architecture-specific i.e. they apply to any Machine with the same Architecture as that of the Target for which the Package is Built.
	4) If the Recipes produce Packages that are Machine-specific, then the default value should be modified in the Recipes as:
		=> PACKAGE_ARCH = "${MACHINE_ARCH}"
		---> It ensures that the Package generated is only used with the Machine it was Built for.
	5) If the Recipes produce Packages that do not contain anything specific to the Target Machine or Architecture (like scripts or documentation etc).
	6) These Packages are identical across all Target Architectures and they need not be Built separately for each Machine or Architecture.
	7) The 'allarch' Class must be inherited in the Recipes for the Packages that are Architecture independent:
		=> inherit allarch

Significance of Package Architecture:
*************************************
1. The Package Architecture is not critical while Building the Image for the first few times.
2. During the initial Build, the priority is to focus on the functionality. The 'PACKAGE_ARCH' and other Architecture related settings can be temporarily ignored.
3. After the Recipes stabilize, it becomes necessary to define the correct Package Architecture for the Build efficiency and Package deployment.
	1) If the Package Architecture is wrongly marked, the Build system may skip necessary re-Building Packages or re-Building of unnecessary Packages.
	2) The BitBake uses the checksums and the Meta-data to determine the Packages re-Building.
	3) In the multi-Machine or multi-Architecture Build system, the incorrect Package Architectures can lead to incompatible binaries deployment.
	4) It can also cause unexpected errors or misbehavior due to missing Packages on the Target.
4. It is important to ensure that the Recipes are re-Build appropriately in response to changes in Configurations and the correct Packages are installed on the Target.

Post-Installation Scripts:
==========================
1. The post-install scripts run immediately after the Package installation on the Target or during the Image creation when the Package is included in the Image.
2. To add a post-install script to a Package, the 'pkg_postinst:PACKAGENAME' function must be added to the Recipe file.
	=> pkg_postinst:PACKAGENAME() {
	=> 	    # Commands to carry out
	=> }
	---> The 'PACKAGENAME' is the name of the Package that should be attached to the 'postinst' script.
3. If the Recipe's main Package is to be attached to the 'postinst' script, the '${PN}' value should be specified in 'PACKAGENAME'.
4. The script defined in the 'pkg_postinst' function is called when the RootFS is created. If the script succeeds, the Package is marked as installed.
5. Any RPM post-install script that runs on the Target should return zero as exit code.
	1) The RPM does not allow non-zero exit codes for these scripts.
	2) The RPM Package manager will cause the Package installation to fail on the Target for non-zero exit codes.

Delaying Post-Install Scripts Execution:
****************************************
1. Sometimes it is necessary for the execution of a post-install script to be delayed until the first Boot.
2. To delay the script execution until Booting of the Target, the post-install must be explicitly marked.
3. There are 2 ways to execute this case:
	1) Using the 'pkg_postinst_ontarget:PACKAGENAME' function.
	2) Calling the 'postinst_intercept delay_to_first_boot' from the 'pkg_postinst:PACKAGENAME' function.
4. Any failure of a 'pkg_postinst:PACKAGENAME' script (including the exit code '1') triggers an error during the 'do_rootfs' Task and breaks the Build.
5. If there are Recipes that use the 'pkg_postinst:PACKAGENAME' function that have dependency on the non-standard native tools during the RootFS generation.
	1) To include these custom Host utilities, the 'PACKAGE_WRITE_DEPS' variable is used to list these tools in the Recipe file.
	2) Otherwise, those tools may not be available during the Build process and the post-install script execution is deferred until the first Boot.
	3) This kind of deferring of the script execution is undesirable.
	4) And if the RootFS is Read-only, then such first  Boot script executions are impossible.

Other Lifetime Scripts Execution:
*********************************
1. There is equivalent support for pre-install, pre-uninstall and post-uninstall scripts in the Yocto Project.
	1) The 'pkg_preinst' is the pre-install scripts that run immediately before the Packages installation.
	2) The 'pkg_prerm' is the pre-uninstall scripts that run immediately before the Packages removal.
	3) The 'pkg_postrm' is the post-uninstall scripts that run immediately after the Packages removal.
2. They work exactly like the 'pkg_postinst' scripts. However, they only run on the Target and not during the Image Building.
