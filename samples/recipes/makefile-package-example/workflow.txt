Recipe Build for C File Using Makefile:
=======================================
1. This sample Recipe is used to Build the C files using Makefile and include it into the RootFS.
2. The C file must be written with the contents to Build. The Makefile must be written with the contents about the Build process.
3. The next step is to place this C file and Makefile in a directory structure for the BitBake to pick it up during the Build.
4. The Layer can be created and added to the Build system using the 'bitbake-layers' command.
	1) Inside the Layer directory, there is a 'recipes-*' directory that shall contain the Recipes.
	2) The C file, the Makefile and the particular Recipe file to Build this C file shall be placed in this 'recipes-*' directory.
5. It is important to note that the name of the Recipe folder must match with the name of the Recipe file name being used to Build the SW.
6. There should be a sub-directory created inside the Recipe folder named as 'files' to contain the C file and the Makefile for the Build.
7. The Recipe file must be created inside the Recipe folder as per the path pointed to by the 'BBFILES' variable.
	1) The GNU 'make' requires a Recipe file that has the sources listed in the 'SRC_URI' variable.
	2) The 'do_compile' Task is optional as by default the BitBake starts the 'make' command to Compile the SW.
	3) If there is any additional 'make' options, they can be stored in 'EXTRA_OEMAKE' or 'PACKAGECONFIG_CONFARGS' variables.
	4) The BitBake passes these options into the GNU 'make' invocation.
	5) However, the 'do_install' Task is still required in the Recipe file.
	6) The extra flags that need to be passed to the Compiler can be provided using the 'CFLAGS' variable.
8. Once the Recipe file is completed, the Build command can be executed for the Recipe.
9. The list of Tasks to be performed during the Build of this Recipe can be checked using the 'bitbake -c listtasks' command.
10. The various OpenEmbedded Build system variable values can be checked in the BitBake Environment using the 'bitbake -e' command.
11. After the Build is successful, the 'WORKDIR' directory can be checked for the files and directories generated during the Build.
	1) If the 'do_compile' Task is provided explicitly in the Recipe file, it would suppress the default 'do_compile' call from the BitBake.
	2) This can be verified by checking the contents of the 'temp/run.do_compile' log file.
12. The Build for a Recipe can be cleaned using the 'bitbake -c cleanall' command.

Recipe Build for C File Using Makefile without do_compile Task:
===============================================================
1. In the Recipe file, the 'do_compile' Task is removed. This will affect the Build behavior as the default 'do_compile' Task would be called by the BitBake.
2. The 'WORKDIR' directory for the Recipe Build must be cleaned using the 'bitbake -c cleanall' command before trying the Build with these modifications.
3. The Build command can then be executed for the Recipe.
4. It is observed that the 'do_compile' Task for the Recipe is successfully executed. Although, there is no such 'do_compile' Task definition in the Recipe file.
5. The Compilation steps can be verified by checking the 'temp/run.do_compile' log file that points to the latest Compilation stage log.
	1) The 'do_compile' Task is called as default by the BitBake.
	2) The 'do_compile' Task calls the 'base_do_compile' function which verifies if there is a 'Makefile' or 'makefile' or 'GNUmakefile' available.
	3) The 'base_do_compile' function then calls the 'oe_runmake' function which then calls the 'oe_runmake_call' function.
	4) The 'oe_runmake_call' function invokes the 'make' command for Building the C files using the available Makefile.
6. The 'WORKDIR' directory can be checked for the files and directories generated during the Build.
7. The Outputs are exactly the same as obtained during the previous Build with the 'do_compile' Task defined explicitly.

Details of WORKDIR Variable:
****************************
1. The path of the work directory being used to Build a Recipe is specified by the 'WORKDIR' variable. It is located within the 'TMPDIR' directory.
2. It is specific to the Recipe being Built and the system for which the Recipe is getting Built.
3. The default value of the 'WORKDIR' variable is:
	=> ${TMPDIR}/work/${MULTIMACH_TARGET_SYS}/${PN}/${EXTENDPE}${PV}-${PR}
	---> The 'TMPDIR' variable is used to specify the top-level Build Output directory.
	---> The 'MULTIMACH_TARGET_SYS' variable is used to specify the type of the Target system for which the Recipe is being Built.
	---> The 'PN' variable is used to specify the Package name. The name is normally extracted from the Recipe file name.
	---> The 'EXTENDPE' variable is used to specify the prefix for a Recipe's version based on the Epoch of the Recipe. In most cases, it is left blank.
	---> The 'PV' variable is used to specify the Recipe version. The value is normally extracted from the Recipe file name.
	---> The 'PR' variable is used to specify the Recipe revision. The default value is 'r0' and subsequent revisions are 'r1', 'r2' etc.

Details of oe_runmake Function:
*******************************
1. The 'oe_runmake' is a helper function provided by the Yocto Project to run the 'make' command safely and consistently with the right Environment.
2. It is defined in the 'meta/classes/base.bbclass' file. The Class file has the function definition as follows:
	=> oe_runmake() {
	=> 	oe_runmake_call "$@" || die "oe_runmake failed"
	=> }
3. The default behavior of the Tasks like 'do_configure' and 'do_compile' is to call the 'oe_runmake' function if a Makefile is found in the 'SRC_URI' variable.
4. The 'oe_runmake' function is used to:
	1) It passes the 'EXTRA_OEMAKE' settings to the 'make' command.
	2) It displays the 'make' command.
	3) It checks for the errors generated during the 'make' command call.
5. In the OpenEmbedded Environment, it is not recommended to call the 'make' command directly. It should always be called through the 'oe_runmake' function.
6. The 'oe_runmake_call' function is the function that executes the 'make' command along with the other passed settings and displays the 'make' command as well.
	=> oe_runmake_call() {
	=> 	bbnote ${MAKE} ${EXTRA_OEMAKE} "$@"
	=> 	${MAKE} ${EXTRA_OEMAKE} "$@"
	=> }

Including the Recipe into the Image:
====================================
1. Even if the Recipe Build is successful, it would not automatically be included as a part of the Image.
2. The Recipe must be added to the Image Recipe file for it to be included in the Image Build.
3. This can be done by appending the 'IMAGE_INSTALL' variable in the Image Recipe file.
	=> IMAGE_INSTALL:append = " package-name"
	---> The 'package-name' is normally extracted from the Recipe file name.
4. Once the Image Recipe file is updated, the Image Build command can be executed.
5. After the Image Build is successful, the Image can be tested on the Target Device for verifying the Recipe addition.

Running the Added Recipe Yocto Image on QEMU:
=============================================
1. For testing the Built Yocto Image on the Host, QEMU is used to execute the Image on an Emulator mimicking the Target HW.
2. Poky repository provides a script 'runqemu' which allows to start the QEMU for running the Yocto Image.
3. The 'runqemu' script can be executed anywhere in the Build directory after setting up the Build Environment.
	=> runqemu qemuarm core-image-minimal nographic
4. After the Root Login stage is done, it should be verified whether the Cross-Compiled C file binary is present at the correctly installed location.
5. If the C binary is present, execute the binary to verify if the expected Output is displayed.
6. The QEMU can be closed by powering OFF the virtual HW.
	=> poweroff

Recipe and Image Build for C File Using Makefile with 'install' and 'uninstall' Rules:
======================================================================================
1. In the Makefile, the 'install' and the 'uninstall' rules are written for replacing the 'do_install' Task in the Recipe file.
2. In the Recipe file, the 'do_install' Task is removed.
3. This is a way to verify if the default 'do_install' Task by the BitBake can use these rules in the Makefile to place the files into the Image.
4. The 'WORKDIR' directory for the Recipe Build must be cleaned using the 'bitbake -c cleanall' command before trying the Build with these modifications.
5. The Build command can then be executed for the Recipe. It is observed that the 'do_install' Task for the Recipe is successfully executed.
6. However, in the 'WORKDIR' directory, it is observed that no files are installed into the the 'image', the 'package' or the 'packages-split' directories.
7. The Installation steps can be verified by checking the 'temp/run.do_install' log file that points to the latest Installation stage log.
	1) The 'do_install' Task is called as default by the BitBake.
	2) The 'do_install' Task calls the 'base_do_install' function which performs no action.
	3) This proves that the default 'do_install' Task cannot use the 'install' and the 'uninstall' rules of the Makefile.
	4) The 'do_install' Task has to be defined explicitly for the files to be placed into the Image.
8. The 'oe_runmake install' command can be used in the 'do_install' Task that will execute the 'make install' from the Makefile.
	1) Any parameter if expected as an Input to the Makefile must be passed along with the 'oe_runmake install' command.
	2) If the parameter is missed, the Makefile would cause an error in the Recipe Build.
9. After restoring the 'do_install' Task, the Build command can then be executed for the Recipe.
10. The 'WORKDIR' directory can be checked for the files and directories generated during the Build.
11. The Outputs are exactly the same as obtained during the previous Build with the Makefile not defining the 'install' and the 'uninstall' rules.
12. With the updated Recipe, the Image Build command can be executed. After the Image Build is successful, the Image can be tested on QEMU.
	=> runqemu qemuarm core-image-minimal nographic
13. After the Root Login stage is done, it should be verified whether the Cross-Compiled C file binary is present at the correctly installed location.
14. If the C binary is present, execute the binary to verify if the expected Output is displayed.
15. The QEMU can be closed by powering OFF the virtual HW.
	=> poweroff

Recipe Build for C File Using Makefile without 'clean' Rule:
============================================================
1. The Layer can be created and added to the Build system using the 'bitbake-layers' command.
	1) Inside the Layer directory, there is a 'recipes-*' directory that shall contain the Recipes.
	2) The C file, the Makefile and the particular Recipe file to Build this C file shall be placed in this 'recipes-*' directory.
	3) The directory structure must be compatible for the BitBake to pick it up during the Build.
	4) The contents of the C file, the Makefile and the particular Recipe file are same as used in the previous Build with 'install' rule in the Makefile.
2. In the Makefile, the 'clean' rule is removed to verify if there is any change in the Build behavior. This is the only change performed to the Recipe.
3. The Build command can then be executed for the Recipe. It is observed that the Build is successful which is contrary to the expected behavior.
4. There is an error expected from the 'do_configure' Task for the Recipe. The general flow of the 'do_configure' Task can be verified using the 'temp/run.do_configure' log file.
	1) The 'do_configure' Task is called as default by the BitBake.
	2) The 'do_configure' Task calls the 'base_do_configure' function which verifies if there is a 'Makefile' or 'makefile' or 'GNUmakefile' available.
	3) The 'base_do_configure' function then calls the 'oe_runmake clean' function which then calls the 'oe_runmake_call' function.
	4) The 'oe_runmake_call' function invokes the 'make clean' command.
	5) Since, the Makefile doesn't have a 'clean' rule, this should have thrown an error in the Recipe Build.
5. The Configuration steps can verified by checking the 'temp/log.do_configure' log file that points to the latest Configuration stage log.
	1) In the log file, there is no call to 'oe_runmake clean' during the 'do_configure' Task execution.
	2) The possible reason for this Build behavior could be the BitBake has restored the Task from the Shared-State Cache i.e. 'sstate-cache'.
	3) Therefore, even though the Makefile has been modified for the Recipe Build, there is no change observed in the Recipe Build behavior.
6. The BitBake must be forced to execute the 'do_configure' Task instead of restoring from the 'sstate-cache'. This can be achieved using the 'bitbake -C recipe-name' command.
	1) The forced execution throws a warning of 'Tainting Hash'. This happens because the prior signature of that Task is invalidated.
	2) The Task execution throws an error of missing 'clean' rule in the Makefile which causes the 'oe_runmake' to fail.
	3) After this Task execution, if the Recipe Build command is executed, then the error appears in the Recipe Build as well.
7. Since, the Recipe Build has failed, there is no change observed in the 'WORKDIR' directory as compared to the successful Recipe Build.
8. The way to fix this error is to use the 'CLEANBROKEN' Environment variable in the Recipe file.
	1) This variable causes the BitBake to skip the 'oe_runmake clean' command execution during the 'do_configure' Task.
9. The Build command can then be executed for the Recipe. It is observed that the Build is successful.
	1) Although the Makefile doesn't define the 'clean' rule, the Recipe Build is successful as there is no 'make clean' execution performed.
10. The 'WORKDIR' directory can be checked for the files and directories generated during the Build.
11. The Outputs are exactly the same as obtained during the previous Build with the Makefile defining the 'clean' rule.
	1) However, there are certain additional 'sstate-install-*' directories present along with the general expected Outputs.
	2) These are generated during the forced execution of the 'do_configure' Task.
	3) The BitBake would reuse the 'sstate-cache' to restore the pre-Built Task Outputs as required during the execution.
	4) These directories are usually named with the 'sstate-install-' as prefix depending on the Task being restored.
